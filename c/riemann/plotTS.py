#!/usr/bin/env python3

help ='''
Plot the ODE system solution generated by a PETSc TS program.

Run the program with options which generate a t-axis and a solution in
binary format:
   -ts_monitor binary:TDATA -ts_monitor_solution binary:UDATA

The solution is treated as a n-dimensional trajectory if neither option -mx nor
-my is given.  A single plot of all solution components versus t is generated.
This image is either shown on the screen, with matplotlib show(), or a .png
image file is generated.

Otherwise, if the solution has spatial dimensions indicated by -mx (1D) or
-mx and -my (2D) then frames of a movie are generated.  Again these are either
shown on the screen as a movie with show(), or numbered .png image (frame) files
are generated.

This script requires copies or sym-links to
   $PETSC_DIR/lib/petsc/bin/PetscBinaryIO.py
   $PETSC_DIR/lib/petsc/bin/petsc_conf.py
Try "make petscPyScripts" before running this script.

trajectory example: FIXME

1D example using the shallow water problem from riemann.c,acoustic.h:
   $ cd p4pdes-next/riemann
   $ make riemann
   $ ./riemann -problem swater -initial hump -da_grid_x 1000 -limiter minmod -ts_monitor binary:t.dat -ts_monitor_solution binary:q.dat
   $ ./plotTS.py -mx 1000 -dof 2 -c 0 -ylabel "h (height)" -ax -5.0 -bx 5.0 -cellcentered t.dat q.dat
   $ ./plotTS.py -mx 1000 -dof 2 -c 1 -ylabel "h u (momentum)" -ax -5.0 -bx 5.0 -cellcentered t.dat q.dat

2D example: FIXME
'''

import PetscBinaryIO

from sys import exit, stdout
from time import sleep
from argparse import ArgumentParser, RawTextHelpFormatter
import numpy as np
import matplotlib.pyplot as plt

parser = ArgumentParser(description=help,
                        formatter_class=RawTextHelpFormatter)
# positional arguments
parser.add_argument('tfile',metavar='TDATA',
                    help='file from -ts_monitor binary:TDATA')
parser.add_argument('ufile',metavar='UDATA',
                    help='file from -ts_monitor_solution binary:UDATA')
# options
parser.add_argument('-ax',metavar='AX', type=float, default=0.0,
                    help='lower limit of x-axis of computational domain')
parser.add_argument('-ay',metavar='AY', type=float, default=0.0,
                    help='lower limit of y-axis of computational domain')
parser.add_argument('-bx',metavar='BX', type=float, default=1.0,
                    help='upper limit of x-axis of computational domain')
parser.add_argument('-by',metavar='BY', type=float, default=1.0,
                    help='upper limit of y-axis of computational domain')
parser.add_argument('-cellcentered', action='store_true', default=False,
                    help='assume axes are cell-centered')
parser.add_argument('-mx',metavar='MX', type=int, default=-1,
                    help='spatial grid with MX points in x direction; required for 1D and 2D frames')
parser.add_argument('-my',metavar='MY', type=int, default=-1,
                    help='spatial grid with MY points in y direction; required for 2D frames')
parser.add_argument('-dof',metavar='DOF', type=int, default=1,
                    help='degrees of freedom of solution')
parser.add_argument('-c',metavar='C', type=int, default=0,
                    help='component; =0,1,..,dof-1)')
parser.add_argument('-o',metavar='FILE',
                    help='image file FILE (trajectory case)')
parser.add_argument('-oroot',metavar='ROOT',
                    help='frame files ROOT000.png,ROOT001.png,... (1D,2D frames case)')
parser.add_argument('-pause',metavar='X', type=float, default=0.01,
                    help='seconds pause between frames in on-screen movie')
parser.add_argument('-ylabel',metavar='LABEL', default='',
                    help='y-axis labe (1D frames case)')
args = parser.parse_args()

io = PetscBinaryIO.PetscBinaryIO()
t = np.array(io.readBinaryFile(args.tfile)).flatten()
U = np.array(io.readBinaryFile(args.ufile)).transpose()
Udims = np.shape(U)

if len(t) != Udims[1]:
    print('time dimension mismatch: %d != %d' % (len(t),dims[1]))
    exit(1)

spacedim = 0
if args.mx > 0 and args.my < 0:
    spacedim = 1
elif args.mx > 0 and args.my > 0:
    spacedim = 2

print('solution U initially has shape = %s' % str(tuple(Udims)))
if spacedim == 1:
    if Udims[0] != args.mx * args.dof:
        print('spatial dimension mismatch: %d != %d * %d' % \
              (Udims[0],args.mx,args.dof))
        exit(2)
    U = np.reshape(U,(args.mx,args.dof,len(t)))
    dims = np.shape(U)
    print('1D frames case ... solution U now has shape=(%d,%d,%d)' % tuple(dims))
    print('  [time t has length=%d, with dof = %d and mx = %d]' % \
          (dims[-1],dims[1],dims[0]))
elif spacedim == 2:
    if Udims[0] != args.mx * args.my * args.dof:
        print('spatial dimension mismatch: %d != %d * %d * %d' % \
              (Udims[0],args.mx,args.my,args.dof))
        exit(3)
    U = np.reshape(U,(args.my,args.mx,args.dof,len(t)))
    dims = np.shape(U)
    print('2D frames case ... solution U is now shape=(%d,%d,%d,%d)' % tuple(dims))
    print('  [time t has length=%d, with dof = %d, mx = %d, and my = %d]' % \
          (dims[-1],dims[2],dims[1],dims[0]))
else:
    print('trajectory case ...')
    print('solution U has shape=(%d,%d)' % tuple(dims))
    print('time t has length=%d, solution Y has length' % \
          (dims[1],dims[0]))

framescmap = 'jet'  # close to PETSc X windows default; compare inferno,gray

if spacedim > 0:
    if args.oroot:
        print('generating %d files %s000.png .. %s%03d.png:' % \
              (len(t),args.oroot,args.oroot,len(t)-1))
    else:
        print('showing %d frames to screen ...' % len(t))
    if spacedim == 1:
        fig = plt.figure(figsize=(8.0,2.5))
        if args.cellcentered:
            dx = (args.bx - args.ax) / float(args.mx)
            xaxis = np.linspace(args.ax + dx/2.0, args.bx - dx/2.0, num=args.mx)
        else:
            xaxis = np.linspace(args.ax, args.bx, num=args.mx)
        line, = plt.plot(xaxis,U[:,args.c,0])
        plt.xlabel('x')
        plt.ylabel(args.ylabel)
        ymin = np.amin(U[:,args.c,:])
        ymax = np.amax(U[:,args.c,:])
        plt.axis([args.ax, args.bx, ymin, ymax])
        fig.set_tight_layout(True)
    elif spacedim == 2:
        plt.imshow(U[:,:,args.c,0],cmap=framescmap)
    else:
        print('how did I get here?')
        exit(4)
    plt.title('t = %g' % t[0])
    if args.oroot:
        plt.savefig(args.oroot + "%03d.png" % 0)
    else:
        plt.ion()
        plt.show()
    for k in range(len(t)-1):
        print('.', end =' ')
        stdout.flush()
        if spacedim == 1:
            line.set_ydata(U[:,args.c,k+1])
        elif spacedim == 2:
            plt.imshow(U[:,:,args.c,k+1],cmap=framescmap)
        else:
            print('how did I get here?')
            exit(5)
        plt.title('t = %g' % t[k+1])
        if args.oroot:
            plt.savefig(args.oroot + "%03d.png" % (k+1))
        else:
            if args.pause > 0:
                plt.pause(args.pause)
    print('.')
else:
    for k in range(dims[0]):
        plt.plot(t,U[k],label='y[%d]' % k)
    plt.xlabel('t')
    plt.legend()
    if args.filename:
        print('writing trajectory image file %s' % args.o)
        plt.savefig(args.o)
    else:
        plt.show()


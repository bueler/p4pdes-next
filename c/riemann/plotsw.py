#!/usr/bin/env python3

help ='''
Plot the ODE system solution generated by riemann.c with option -problem swater.
(This code is a modification of plotTS.py, a more general plotter.)

Run the program riemann.c with -problem swater.  Save the solution using options
which generate a t-axis and a solution in PETSc binary format:
   -ts_monitor binary:TDATA -ts_monitor_solution binary:QDATA
See examples below.

This script requires copies or sym-links to
   $PETSC_DIR/lib/petsc/bin/PetscBinaryIO.py
   $PETSC_DIR/lib/petsc/bin/petsc_conf.py
Try "make petscPyScripts" before running this script.

Example with flat bathymetry:
   $ cd p4pdes-next/riemann
   $ make riemann
   $ ./riemann -problem swater -initial hump -da_grid_x 1000 -limiter minmod -ts_monitor binary:t.dat -ts_monitor_solution binary:q.dat
   $ ./plotsw.py -mx 1000 -c 0 -ylabel "h (height)" -ax -5.0 -bx 5.0 t.dat q.dat

Example with sloped bathymetry
   $ ./riemann -problem swater -initial hump -b0 -5 -bx -0.9 -da_grid_x 1000 -ts_type ssp -ts_monitor_solution draw
   $ ./riemann -problem swater -initial hump -b0 -5 -bx -0.9 -da_grid_x 1000 -ts_type ssp -ts_monitor binary:t.dat -ts_monitor_solution binary:q.dat
   $ ./plotsw.py -mx 1000 -c 0 -ylabel "surface elevation" -ax -5.0 -bx 5.0 -bath0 -5 -bathx -0.9 t.dat q.dat
(Summary of above views: 1. h and hu to screen, 2. h and hu to files, 3. eta to screen.)
'''

import PetscBinaryIO

from sys import exit, stdout
from time import sleep
from argparse import ArgumentParser, RawTextHelpFormatter
import numpy as np
import matplotlib.pyplot as plt

parser = ArgumentParser(description=help,
                        formatter_class=RawTextHelpFormatter)
# positional arguments
parser.add_argument('tfile',metavar='TDATA',
                    help='file from -ts_monitor binary:TDATA')
parser.add_argument('ufile',metavar='UDATA',
                    help='file from -ts_monitor_solution binary:UDATA')
# options
parser.add_argument('-ax',metavar='AX', type=float, default=0.0,
                    help='lower limit of x-axis of computational domain')
parser.add_argument('-bx',metavar='BX', type=float, default=1.0,
                    help='upper limit of x-axis of computational domain')
parser.add_argument('-bath0',metavar='X', type=float, default=0.0,
                    help='corresponds to "-b0" in riemann -problem swater')
parser.add_argument('-bathx',metavar='X', type=float, default=0.0,
                    help='corresponds to "-bx" in riemann -problem swater')
parser.add_argument('-mx',metavar='MX', type=int, default=-1,
                    help='spatial grid with MX points in x direction')
parser.add_argument('-c',metavar='C', type=int, default=0,
                    help='component; =0,1,..,dof-1)')
parser.add_argument('-oroot',metavar='ROOT',
                    help='frame files ROOT000.png,ROOT001.png,...')
parser.add_argument('-pause',metavar='X', type=float, default=0.01,
                    help='seconds pause between frames in on-screen movie')
parser.add_argument('-ylabel',metavar='LABEL', default='',
                    help='y-axis label')
args = parser.parse_args()

io = PetscBinaryIO.PetscBinaryIO()
t = np.array(io.readBinaryFile(args.tfile)).flatten()
U = np.array(io.readBinaryFile(args.ufile)).transpose()
Udims = np.shape(U)

if len(t) != Udims[1]:
    print('time dimension mismatch: %d != %d' % (len(t),dims[1]))
    exit(1)

print('solution U initially has shape = %s' % str(tuple(Udims)))
if Udims[0] != 2 * args.mx:
    print('spatial dimension mismatch: %d != 2 * %d' % \
          (Udims[0],args.mx))
    exit(2)
U = np.reshape(U,(args.mx,2,len(t)))
dims = np.shape(U)
print('1D frames case ... solution U now has shape=(%d,%d,%d)' % tuple(dims))
print('  [time t has length=%d, with dof = %d and mx = %d]' % \
      (dims[-1],dims[1],dims[0]))

framescmap = 'jet'  # close to PETSc X windows default; compare inferno,gray

if args.oroot:
    print('generating %d files %s000.png .. %s%03d.png:' % \
          (len(t),args.oroot,args.oroot,len(t)-1))
else:
    print('showing %d frames to screen ...' % len(t))

fig = plt.figure(figsize=(8.0,2.5))
dx = (args.bx - args.ax) / float(args.mx)
xaxis = np.linspace(args.ax + dx/2.0, args.bx - dx/2.0, num=args.mx)

# here is the modification to show surface elevation:
if args.bathx != 0.0 and args.c == 0:
    for k in range(len(t)):
        U[:,args.c,k] += args.bath0 + args.bathx * xaxis

line, = plt.plot(xaxis,U[:,args.c,0])
plt.xlabel('x')
plt.ylabel(args.ylabel)
ymin = np.amin(U[:,args.c,:])
ymax = np.amax(U[:,args.c,:])
plt.axis([args.ax, args.bx, ymin, ymax])
fig.set_tight_layout(True)

plt.title('t = %g' % t[0])
if args.oroot:
    plt.savefig(args.oroot + "%03d.png" % 0)
else:
    plt.ion()
    plt.show()
for k in range(len(t)-1):
    print('.', end =' ')
    stdout.flush()
    line.set_ydata(U[:,args.c,k+1])
    plt.title('t = %g' % t[k+1])
    if args.oroot:
        plt.savefig(args.oroot + "%03d.png" % (k+1))
    else:
        if args.pause > 0:
            plt.pause(args.pause)
print('.')

